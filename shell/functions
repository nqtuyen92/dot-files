# Functions:
# [pathmunge man dict ips rename extract histop itunes]

pathmunge() {
	case ":${PATH}:" in
		*:"$1":* | "$1:${PATH}:")
			# $1 is already contained or $1 is NIL
			;;
		*)
			if [ "$2" = "after" ]
			then
				PATH=$PATH:$1
			else
				PATH=$1:$PATH
			fi
	esac
}
#[ -d "/usr/local/mysql" ] && pathmunge "/usr/local/mysql/bin" "after"
#[ -d "/Users/xinyi/Workspace/android-sdks/platform-tools" ] && pathmunge "/Users/xinyi/Workspace/android-sdks/platform-tools" "after"
[ -d "/Applications/Qt/Qt5.1.1/5.1.1/clang_64/bin" ] && pathmunge "/Applications/Qt/Qt5.1.1/5.1.1/clang_64/bin" "after"
[[ -d "/Applications/TeX/texlive/2013basic/bin/x86_64-darwin" ]] && pathmunge "/Applications/TeX/texlive/2013basic/bin/x86_64-darwin" "after"
unset pathmunge

man () {
	env \
	LESS_TERMCAP_mb=$(printf "\e[1;31m") \
	LESS_TERMCAP_md=$(printf "\e[1;31m") \
	LESS_TERMCAP_me=$(printf "\e[0m") \
	LESS_TERMCAP_se=$(printf "\e[0m") \
	LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
	LESS_TERMCAP_ue=$(printf "\e[0m") \
	LESS_TERMCAP_us=$(printf "\e[1;32m") \
	man "$@"
}

if [ -d "/etc/profile.d" ]
then
	for i in /etc/profile.d/*.sh
	do
		if [ -r "$i" ]
		then
			if [ "$PS1" ]
			then
				. "$i"
			else
				. "$i" > /dev/null 2>&1
			fi
		fi
	done
	unset i
fi

# look words in mac's dict
dict() {
	grep "$@" /usr/share/dict/words
}

# show ip
ips() {
	/sbin/ifconfig | awk '/inet / && !/127.0.0.1/ {print $2}'
}

# rename file or directory
function rename() {
	[[ $# -eq 2 ]] || { echo "Usage: rename <old_name> <new_name>"; return 1; }
	[[ $# -eq 2 ]] || { echo "Usage: $0 <old_name> <new_name>" ; return 1; }
	[ -e "$1" ] || { echo "No such file or directory:" $1; return 1; }
	[ "$1" != "$2" ] || { echo the same name; return 1; }
	mv -i $1 $2
	[ $? -eq 0 ] || { echo "rename error"; return 1; }
	return 0
}

# extract files from compressed status
# TODO: test if the extract binary exists
# 	case $1 in
# 		*.tar.gz)	prog=tar args=xzf ;;
#	esac
#	if whence $prog
#		$prog $args $1
#	else
#		echo "extract needs $prog, but not exist"
#	fi
extract () {
    while (( $# > 0 )); do
        echo $@
	    if [[ -f $1 ]]
	    then
		    case $1 in
			  *.tar.bz2|*.tbz|*.tbz2) tar xjf $1 ;;
			  *.tar.gz|*.tgz) tar xzf $1 ;;
			  *.bz2) bunzip2 $1 ;;
			  *.rar) unrar x $1 ;;
			  *.gz) gunzip $1 ;;
			  *.tar) tar xf $1 ;;
			  *.zip|*.war|*.jar) unzip $1 ;;
			  *.tar.Z) uncompress $1; set -- $@ ${1:0:-2} ;;
              *.Z) uncompress $1 ;;
              *.tar.xz) xz --decompress $1; set -- $@ ${1:0:-3} ;;
              *.txz) mv $1 ${1:0:-4}.tar.xz; set -- $@ ${1:0:-4}.tar.xz ;;
			  *.xz) xz --decompress $1 ;;
              *.7z) 7za x $1 ;;
              *.rar) unrar x ad $1 ;;
			  *) echo "'$1' cannot be extracted via extract" 1>&2 ;;
		    esac
	    else
		    echo "extract: '$1' is not a valid file" 1>&2
	    fi
        shift
    done
}

compdef '_files -g "*.gz *.tgz *.txz *.xz *.7z *.Z *.bz2 *.tbz *.zip *.rar *.tar *.lha"' extract

# History accepts a range in zsh entries as [first] [last] arguments, so to
# get them all run history 1.
# Note that the history list starts at 1 and not 0
# print top command in history
function histop() {
	local FNAME='histop'
	local n=10
	if [[ $# -ne 0 ]]; then
		case $1 in
			-h|--help)
				echo "Usage: $FNAME -n <num>"
				echo "num: print num lines of most used command"
				return 0
				;;
			-n)
				if [ $# -eq 2 -a $2 -ge 1 -a $2 -le $HISTSIZE ]; then
					n=$2
					shift
				else
					echo "option -n needs an number"
					return 1
				fi
				;;
			*)
				echo "$FNAME: Unknown option: $1"
				$FNAME --help
				return 1
				;;
		esac
		shift
	fi
	print "Number\tTimes\tFrequency\tCommand"
	history 1 | awk -v n=$n '{ cmds[$2]++; } END { i = 1; for (cmd in cmds) {
		if (i++ <= n) printf("%-8d%8.2f%%\t%-16s\n", cmds[cmd],
			(100*cmds[cmd])/NR, cmd); else break; }}' | sort -nr | nl
}

# iTunes control function
function itunes() {
	local opt=$1
	shift
	case "$opt" in
		launch|play|pause|stop|rewind|resume|quit)
			;;
		mute)
			opt="set mute to true"
			;;
		unmute)
			opt="set mute to false"
			;;
		next|previous)
			opt="$opt track"
			;;
		""|-h|--help)
			echo "Usage: itunes <option>"
			echo "option:"
			echo "\tlaunch|play|pause|stop|rewind|resume|quit"
			echo "\tmute|unmute\tcontrol volume set"
			echo "\tnext|previous\tplay next or previous track"
			echo "\thelp\tshow this message and exit"
			return 0
			;;
		*)
			print "Unkonwn option: $opt"
			return 1
			;;
	esac
	osascript -e "tell application \"iTunes\" to $opt"
}

# use alias rm='trash' to play safer
function trash() {
	local TRASH
	case "`uname -s`" in
		Darwin)
			TRASH=~/.Trash
			;;
		Linux)
			TRASH=~/.trash
			;;
		*)
			echo "Unsupported system" && return 0
			;;
	esac
	case "$1" in
		""|-h|--help)
			echo "Usage: trash [files or directories]"
			;;
		*)
			for item in "$@"; do
				if [[ ! -e $item ]]; then
					echo "$item :No such file or directory, skipped"
					# uncomment the following line to abort if non-exists
					#return 1
					continue
				fi
				local dst=${TRASH}/$(basename $item)
				while [[ -e $dst ]]; do
					dst="${dst}+"
				done
				mv $item $dst
			done
			;;
	esac
}

function unix2dos() {
    [[ "$#" -eq 0 ]] && echo "Usage: unix2dos <file>" ||
    perl -i -p -e 's/\n/\r\n/' "$1"
}

function dos2unix() {
    [[ "$#" -eq 0 ]] && echo "Usage: dos2unix <file>" ||
    perl -i -p -e 's/\r\n/\n/' "$1"
}

# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
